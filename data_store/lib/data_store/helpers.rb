module DataStore

  # This module is container for a couple of different mechanisms for generating keys.
  # You can add your own key generator module by having it implementing a class method 
  # <i> generate </i> and extending it in your model class
  module KeyGenerators
    
    # This module is a sequence implementation of the key generator module.
    # It uses the Berkely DB sequence to generate keys
    # <br> <br> <b> Usage Example </b><br>
    #   class Model
    #     extend DataStore::KeyGenerators::SequenceKey
    #   end
    module SequenceKey
    
      # Returns a string generated by the BerkeleyDB sequence.
      # Creates a sequence for the DB with initial value 1 if none exists.
      def generate(object)
        (@sequence ||= ->(){
          seq = Bdb::DbSequence.new(db_handle, db_name + "_seq", 0)
          seq.initial_val(1)
          seq.open(nil, Bdb::DB_CREATE)
          seq
        }.call()).get(nil, 1, 0).to_s
      end
      
    end

    # This module is a realtime key generator for the key.
    # It uses current time, thead_id along with process_id
    # to generate a unique time-based key
    # <br> <br> <b> Usage Example </b><br>
    #   class Model
    #     extend DataStore::KeyGenerators::RealtimeKey
    #   end
    module RealtimeKey

      # Returns a string generated by using a combination of time, thread_id, process_id.
      def generate(object)
        return "#{(Time.now.to_f * 100000).to_i.to_s(36)}:#{Thread.current.__id__}:#{Process.pid.to_s(36)}"
      end

    end
    
  end
  
end
